import { readFileSync, writeFileSync, existsSync } from 'fs';
import { resolve, dirname } from 'path';
import { fileURLToPath } from 'url';

const ROOT = resolve(dirname(fileURLToPath(import.meta.url)), '..');
const RESULTS_PATH = resolve(ROOT, 'playwright-report', 'results.json');
const OUTPUT_PATH = resolve(ROOT, 'e2e', 'README.md');

interface TestResultEntry {
  status: 'passed' | 'failed' | 'timedOut' | 'skipped' | 'interrupted';
}

interface TestEntry {
  status: 'expected' | 'unexpected' | 'skipped' | 'flaky';
  results: TestResultEntry[];
}

interface TestCase {
  title: string;
  ok: boolean;
  tests: TestEntry[];
}

interface Suite {
  title: string;
  file: string;
  suites?: Suite[];
  specs?: TestCase[];
}

interface PlaywrightReport {
  suites: Suite[];
  stats: {
    expected: number;
    unexpected: number;
    skipped: number;
    flaky: number;
  };
}

const STATUS_ICONS: Record<string, string> = {
  expected: '✅',
  unexpected: '❌',
  skipped: '⏭️',
  flaky: '⚠️',
};

const fixtureToSite: Record<string, string> = {
  imdb: 'IMDb',
  trakt: 'Trakt',
  google: 'Google Search',
  bing: 'Bing Search',
  justwatch: 'JustWatch',
  netflix: 'Netflix',
  amazon: 'Amazon',
};

const collectTests = (suite: Suite): Array<{ group: string; title: string; status: string }> => {
  const results: Array<{ group: string; title: string; status: string }> = [];

  const walk = (s: Suite, parentTitle: string): void => {
    const groupTitle = parentTitle ? `${parentTitle} › ${s.title}` : s.title;

    if (s.specs) {
      for (const spec of s.specs) {
        const testEntry = spec.tests[0];
        const status = testEntry?.status ?? 'skipped';
        results.push({
          group: groupTitle,
          title: spec.title,
          status,
        });
      }
    }

    if (s.suites) {
      for (const child of s.suites) {
        walk(child, groupTitle);
      }
    }
  };

  walk(suite, '');
  return results;
};

const generate = (): void => {
  if (!existsSync(RESULTS_PATH)) {
    console.error(`No results file found at ${RESULTS_PATH}. Run tests first.`);
    process.exit(1);
  }

  const report: PlaywrightReport = JSON.parse(readFileSync(RESULTS_PATH, 'utf-8'));
  const { expected, unexpected, skipped, flaky } = report.stats;
  const total = expected + unexpected + skipped + flaky;
  const allPassed = unexpected === 0;

  const lines: string[] = [
    '# E2E Test Results',
    '',
    `> Auto-generated by \`scripts/generate-e2e-readme.ts\` from Playwright JSON results.`,
    '',
    `| Metric | Count |`,
    `| --- | --- |`,
    `| ${STATUS_ICONS.expected} Passed | ${expected} |`,
    `| ${STATUS_ICONS.unexpected} Failed | ${unexpected} |`,
    `| ${STATUS_ICONS.skipped} Skipped | ${skipped} |`,
    `| ${STATUS_ICONS.flaky} Flaky | ${flaky} |`,
    `| **Total** | **${total}** |`,
    '',
    `**Overall: ${allPassed ? '✅ All tests passed' : '❌ Some tests failed'}**`,
    '',
    '---',
    '',
  ];

  for (const suite of report.suites) {
    const siteName =
      Object.entries(fixtureToSite).find(([key]) => suite.file.includes(key))?.[1] ?? suite.title;

    const tests = collectTests(suite);

    const passed = tests.filter((t) => t.status === 'expected').length;
    const failed = tests.filter((t) => t.status === 'unexpected').length;
    const siteIcon = failed > 0 ? '❌' : '✅';

    lines.push(`## ${siteIcon} ${siteName} (${passed}/${tests.length})`);
    lines.push('');
    lines.push('| Status | Test |');
    lines.push('| --- | --- |');

    for (const t of tests) {
      const icon = STATUS_ICONS[t.status] ?? '❓';
      lines.push(`| ${icon} | ${t.title} |`);
    }

    lines.push('');
  }

  lines.push('---');
  lines.push('');
  lines.push(
    '*Fixtures are located in `e2e/fixtures/`. Update them when site DOM structures change.*',
  );
  lines.push('');

  writeFileSync(OUTPUT_PATH, lines.join('\n'));
  console.log(`E2E README generated at ${OUTPUT_PATH}`);
};

generate();
